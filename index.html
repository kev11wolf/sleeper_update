<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sleeper Matchups ‚Äî League 1257480275340828672</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#121822;
      --text:#e6eef8;
      --muted:#9fb3c8;
      --accent:#4aa3ff;
      --ok:#2ecc71;
      --warn:#f39c12;
      --danger:#e74c3c;
      --chip:#223045;
      --code:#11161f;
      --border:#1f2a38;
    }
    :root.light {
      --bg: #fafafa;
      --panel: #ffffff;
      --text: #000000;
      --muted: #666666;
      --accent: #0077cc;
      --ok: #2ecc71;
      --warn: #f39c12;
      --danger: #e74c3c;
      --chip: #e0e0e0;
      --code: #f5f5f5;
      --border: #cccccc;
    }
    html,body {
      margin:0;
      background:var(--bg);
      color:var(--text);
      font:14px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif
    }
    header {
      position: relative;
      padding: 20px 16px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
    }
    h1 {
      margin: 0;
      font-size: 18px
    }
    .sub {
      color: var(--muted);
      font-size: 13px;
      margin-top: 4px;
    }
    .header-actions {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .leagueBtn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--text);
      text-decoration: none;
      border: 1px solid var(--border);
      background: var(--panel);
      padding: 8px 12px;
      border-radius: 8px;
      font-weight: 600;
    }
    .leagueBtn:hover {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(74,163,255,.15)
    }
    .leagueBtn svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
    }
    /* Audio player styles */
    .audio-player {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .audio-player audio {
      width: 200px;
      outline: none;
    }
    .audio-player audio::-webkit-media-controls-panel {
      background: var(--panel);
      color: var(--text);
    }
    .audio-player audio::-webkit-media-controls-play-button,
    .audio-player audio::-webkit-media-controls-volume-slider {
      color: var(--text);
    }
    .audio-player audio::-webkit-media-controls-current-time-display,
    .audio-player audio::-webkit-media-controls-time-remaining-display {
      color: var(--text);
    }
    /* Ensure audio player doesn't overlap league button */
    @media (max-width: 600px) {
      .header-actions {
        flex-direction: column;
        align-items: flex-end;
      }
      .audio-player {
        top: 60px; /* Adjust to avoid overlap with leagueBtn */
      }
    }
    main {
      padding: 16px;
      max-width: 1200px;
      margin: 0 auto
    }
    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 12px
    }
    button,.btn {
      appearance: none;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600
    }
    button:hover {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(74,163,255,.15)
    }
    .pill {
      background: var(--chip);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 4px 8px;
      color: var(--muted);
      display: inline-block;
      margin: 2px 2px 2px 0;
    }
    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px
    }
    details {
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      background: var(--panel)
    }
    summary {
      cursor: pointer;
      padding: 12px 14px;
      font-weight: 700;
      background: rgba(255,255,255,0.02)
    }
    summary:hover {
      background: rgba(255,255,255,0.05)
    }
    .wk {
      padding: 10px 12px;
      -webkit-overflow-scrolling: touch;
    }
    .err {
      color: var(--danger);
      font-weight: 700
    }
    pre {
      background: var(--code);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      overflow: auto;
      color: #d7e3f4
    }
    small {
      color: var(--muted)
    }
    .mono {
      font-family: ui-monospace,SFMono-Regular,Menlo,Consolas,monospace
    }
    /* The existing "matchup-row" and "matchup-summary" classes won't apply here
       since we're changing the matchups to be in <details> blocks. 
       We'll keep them just unused to avoid altering other code references. */
    .matchup-row {}
    .matchup-summary {}

    /* Mobile responsiveness for the stack layout */
    @media (max-width: 768px) {
      .wk {
        padding: 10px 8px;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Sleeper League Matchups</h1>
    <div class="sub" id="subtitle">Loading...</div>
    <div class="header-actions">
      <a
        href="https://sleeper.com/leagues/1257480275340828672"
        target="_blank"
        class="leagueBtn"
        aria-label="Go to Sleeper League Page">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M21.95 11.29c-.64-1.63-3.55-6.28-9.6-6.28-6.05 0-8.96 4.65-9.6 6.28-.09.23-.09.49 0 .72.64 1.63 3.55 6.28 9.6 6.28 6.05 0 8.96-4.65 9.6-6.28.09-.23.09-.49 0-.72zM12 16c-1.83 0-3.55-.21-5-.62-.12-.03-.18-.17-.11-.28.32-.49.68-1.12 1-1.78.07-.15.23-.2.4-.17 1.07.17 2.19.26 3.29.26 1.09 0 2.21-.09 3.28-.26.17-.03.33.02.4.17.32.66.67 1.29.99 1.78.07.11.01.25-.11.28-1.45.41-3.17.62-5 .62z"></path>
        </svg>
        Sleeper
      </a>
      <div class="audio-player">
        <audio controls>
          <source src="https://raw.githubusercontent.com/kev11wolf/sleeper_update/main/All%20NFL%20Songs%20on%20Television.mp3" type="audio/mpeg" />
          Your browser does not support the audio element.
        </audio>
        <p style="margin:0; color:var(--muted); font-size:12px;">Now playing: NFL theme songs</p>
      </div>
    </div>
  </header>
  <main>
    <div class="row">
      <button id="refreshBtn">üîÑ Refresh</button>
      <button id="downloadJsonBtn">‚¨áÔ∏è Download JSON</button>
      <button id="downloadCsvBtn">‚¨áÔ∏è Download CSV</button>
      <button id="themeToggleBtn">Toggle Theme</button>
      <span class="pill" id="metaPill">Season: ‚Äî ¬∑ Week: ‚Äî</span>
      <span class="pill" id="countPill">Matchups: ‚Äî</span>
    </div>
    <div id="errors" class="card" style="display:none"></div>
    <div class="card" style="margin-top:24px;">
      <h3>Congratulations to Week 3 high point scorer, Tush Push Merchants!</h3>
<p>Tush Push Merchants, you sly, scoring beast,</p>
<p>Violating Chubb-y Dicker with a 145-point feast!</p>
<p>Your fantasy nuts left their defense deceased!</p>
    </div>
    <div class="card" style="margin-top:24px;">
      <h3>NFL News Update - Week 3</h3>
      <p>
Folks, Week 3 was a shitshow where the Bears finally grew a pair and Caleb Williams bombed Dallas for four TDs in a 31-14 smackdown that had Jerry Jones looking like he just caught his wife with the pool boy, while the Eagles pulled a miracle comeback against the Rams highlighted by Jordan Davis blocking a field goal and returning it for a TD like he was personally offended by the kicker's existence. Injuries hit like a bad hangover‚ÄîNick Bosa's knee buckled into season-ending ACL oblivion for the 49ers, James Conner got carted off the Cardinals with a leg that looked like it lost a fight with a lawnmower, and Najee Harris tore his Achilles so bad the Chargers' backfield now runs on hopes and prayers, leaving fantasy nerds everywhere jerking tears into their energy drinks. Off the field, Tom Brady's divorce drama escalated with Gisele spilling tea about his "deflated priorities" that had nothing to do with football but everything to do with his ego being bigger than a Thanksgiving turducken, proving even retired QBs can't quit being walking punchlines.
      </p>
    </div>

    <!-- NEW CARD FOR LEAGUE RECORDS -->
    <div class="card" style="margin-top:24px;" id="recordsCard">
      <h3>League Records & Stats</h3>
      <ul id="recordsList" style="list-style:none; padding-left:0;"></ul>
    </div>

    <div id="weeksContainer" class="stack"></div>
    <h3 style="margin-top:24px; display:none;">Raw (combined) JSON</h3>
    <pre id="raw" aria-live="polite" style="display:none;">‚Äî</pre>
    <p style="display:none;">
      <small>
        Tips: Points show any commissioner override (<span class="mono">custom_points</span>) otherwise normal total (<span class="mono">points</span>).
        Starters and players (per team) are preserved in the JSON export.
      </small>
    </p>
  </main>
  <script>
  (function () {
    const LEAGUE_ID = "1257480275340828672";
    const BASE = "https://api.sleeper.app/v1";
    const SUMMARY_JSON_URL = "summaries.json";
    let summariesData = {};
    let allPlayersData = {};
    // We'll store each roster's avatar URL in a map for easy lookup anywhere we display team names
    const rosterToAvatar = new Map();

    async function fetchSummaries() {
      try {
        const res = await fetch(SUMMARY_JSON_URL);
        if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        const data = await res.json();
        return data;
      } catch (err) {
        console.warn("Could not fetch summaries JSON:", err);
        return { summaries: {} };
      }
    }

    const els = {
      subtitle: document.getElementById("subtitle"),
      metaPill: document.getElementById("metaPill"),
      countPill: document.getElementById("countPill"),
      weeksContainer: document.getElementById("weeksContainer"),
      raw: document.getElementById("raw"),
      errors: document.getElementById("errors"),
      refreshBtn: document.getElementById("refreshBtn"),
      downloadJsonBtn: document.getElementById("downloadJsonBtn"),
      downloadCsvBtn: document.getElementById("downloadCsvBtn"),
      themeToggleBtn: document.getElementById("themeToggleBtn")
    };

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    function fmt(n) {
      if (n === null || n === undefined) return "‚Äî";
      return Number(n).toLocaleString(undefined, { maximumFractionDigits: 2 });
    }
    function toCSV(rows) {
      const headers = Object.keys(rows[0] || {});
      const escape = (val) => {
        const s = (val ?? "").toString();
        if (s.includes('"') || s.includes(',') || s.includes('\n')) {
          return `"${s.replace(/"/g, '""')}"`;
        }
        return s;
      };
      return [headers.join(","), ...rows.map(r => headers.map(h => escape(r[h])).join(","))].join("\n");
    }
    function download(name, mime, text) {
      const blob = new Blob([text], { type: mime });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = name;
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(url);
      a.remove();
    }
    function showError(html) {
      els.errors.style.display = "block";
      els.errors.innerHTML = html;
    }
    function clearError() {
      els.errors.style.display = "none";
      els.errors.textContent = "";
    }
    async function fetchJson(url, opts={}) {
      for (let attempt = 1; attempt <= 3; attempt++) {
        try {
          const res = await fetch(url, { cache: "no-cache", ...opts });
          if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
          return await res.json();
        } catch (err) {
          if (attempt === 3) throw err;
          await sleep(250 * attempt);
        }
      }
    }
    function deriveTeamName(user) {
      const meta = user?.metadata || {};
      const preferred = meta.team_name || meta.team_name_display || meta.team_name_full;
      return preferred || user?.display_name || user?.username || "Unknown Team";
    }
    function effectivePoints(m) {
      if (m.custom_points !== null && m.custom_points !== undefined) {
        return m.custom_points;
      }
      return m.points ?? 0;
    }
    function flattenForCsv(allMatchups) {
      const rows = [];
      for (const m of allMatchups) {
        const highest = Math.max(...m.teams.map(t => t.points ?? 0));
        const winners = m.teams.filter(t => (t.points ?? 0) === highest).map(t => t.roster_id);
        for (const t of m.teams) {
          const bench = (t.players || []).filter(p => !(t.starters || []).includes(p));
          rows.push({
            season: m.season,
            week: m.week,
            matchup_id: m.matchup_id,
            roster_id: t.roster_id,
            team_name: t.team_name,
            owner_display: t.owner_display,
            points: t.points ?? "",
            is_winner: winners.includes(t.roster_id) && winners.length === 1 ? "TRUE"
                       : winners.includes(t.roster_id) && winners.length > 1 ? "TIE" : "FALSE",
            starters: (t.starters || []).join(";"),
            players: (t.players || []).join(";"),
            bench: bench.join(";")
          });
        }
      }
      return rows;
    }

    // Helper to return avatar snippet + team name, with a consistent style
    function avatarAndName(rid, teamName) {
      const url = rosterToAvatar.get(rid) || "";
      if (!url) return teamName; // no avatar available
      return `<img src="${url}" alt="${teamName} avatar" style="width:20px; height:20px; border-radius:50%; margin-right:4px;">${teamName}`;
    }

    // Renders the matchups so each week is in a <details> block,
    // and within each week, each matchup is *also* in a collapsed <details> block.
    function renderWeeks(grouped, allSummaries) {
      els.weeksContainer.innerHTML = "";
      const weeks = Object.keys(grouped).map(n => Number(n)).sort((a,b) => a-b);
      weeks.forEach(week => {
        const list = grouped[week];
        const weekDetails = document.createElement("details");
        weekDetails.open = false;
        const summary = document.createElement("summary");
        summary.innerHTML = `Week ${week} ‚Äî ${list.length} matchup${list.length !== 1 ? "s" : ""}`;
        weekDetails.appendChild(summary);

        const container = document.createElement("div");
        container.className = "wk";

        for (const m of list) {
          const teams = [...m.teams].sort((a,b) => a.roster_id - b.roster_id);
          const highest = Math.max(...teams.map(t => t.points ?? 0));
          const winners = teams.filter(t => (t.points ?? 0) === highest);
          const isTie = winners.length > 1;
          const moreTeams = teams.length > 2;

          const matchDetails = document.createElement("details");
          matchDetails.open = false;

          // Build the clickable summary text for the matchup:
          const scoreboardSummary = (() => {
            if (moreTeams) {
              // e.g. "Matchup #2 (3+ teams) - top score: X pts"
              return `
                Matchup #${m.matchup_id} (multi-team, ${teams.length} total) 
                ${isTie ? `<span class="tie">Tie (${fmt(highest)})</span>` 
                        : `Winner: <span class="win">${winners[0]?.team_name || "‚Äî"}</span> (${fmt(highest)})`}
              `;
            } else {
              // Just 2 teams
              const a = teams[0], b = teams[1];
              const winnerText = isTie
                ? `<span class="tie">Tie (${fmt(highest)})</span>`
                : `<span class="win">${winners[0]?.team_name || "‚Äî"}</span>`;
              return `
                Matchup #${m.matchup_id} ‚Äî 
                ${avatarAndName(a?.roster_id, a?.team_name || "‚Äî")} (${fmt(a?.points)}) 
                vs 
                ${avatarAndName(b?.roster_id, b?.team_name || "‚Äî")} (${fmt(b?.points)}) 
                | ${winnerText}
              `;
            }
          })();

          const summaryTag = document.createElement("summary");
          summaryTag.innerHTML = scoreboardSummary;
          matchDetails.appendChild(summaryTag);

          // Now the hidden details content:
          const detailDiv = document.createElement("div");
          detailDiv.style.marginTop = "8px";
          const summaryText = allSummaries?.[week]?.[m.matchup_id] || "No matchup summary provided.";
          let detailHTML = `<p style="margin:8px 0;">${summaryText}</p>`;

          if (moreTeams) {
            // Multi-team display: list all teams and scores
            const listing = teams.map(t => `${avatarAndName(t.roster_id, t.team_name)} (${fmt(t.points)})`).join(" &bull; ");
            detailHTML += `<div><strong>All Teams:</strong> ${listing}</div>`;
          } else {
            // Just 2 teams. Show starters
            const a = teams[0], b = teams[1];
            const aStartersHtml = (a.starters || [])
              .map(s => {
                const [pid, fullName] = s.split(" // ");
                const pos = allPlayersData[pid]?.position || "UNK";
                const points = a.players_points?.[pid] ?? 0;
                return `<span class="pill">${fullName || "defense"} (${pos}, ${fmt(points)} pts)</span>`;
              })
              .join(" ");
            const bStartersHtml = (b.starters || [])
              .map(s => {
                const [pid, fullName] = s.split(" // ");
                const pos = allPlayersData[pid]?.position || "UNK";
                const points = b.players_points?.[pid] ?? 0;
                return `<span class="pill">${fullName || "defense"} (${pos}, ${fmt(points)} pts)</span>`;
              })
              .join(" ");

            detailHTML += `
              <div style="margin-top:8px; display:flex; gap:16px; flex-wrap:wrap;">
                <div style="flex:1; min-width:0;">
                  <strong>${avatarAndName(a.roster_id, a.team_name)} Starters</strong>
                  <div style="margin:6px 0; display:flex; flex-wrap:wrap; gap:4px;">
                    ${aStartersHtml}
                  </div>
                </div>
                <div style="flex:1; min-width:0;">
                  <strong>${avatarAndName(b.roster_id, b.team_name)} Starters</strong>
                  <div style="margin:6px 0; display:flex; flex-wrap:wrap; gap:4px;">
                    ${bStartersHtml}
                  </div>
                </div>
              </div>
            `;
          }

          detailDiv.innerHTML = detailHTML;
          matchDetails.appendChild(detailDiv);
          container.appendChild(matchDetails);
        }

        weekDetails.appendChild(container);
        els.weeksContainer.appendChild(weekDetails);
      });
    }

    async function load() {
      clearError();
      els.subtitle.textContent = "Fetching data...";
      els.raw.textContent = "Loading‚Ä¶";
      try {
        summariesData = await fetchSummaries();
        allPlayersData = await fetchJson(`${BASE}/players/nfl`);
        const state = await fetchJson(`${BASE}/state/nfl`);
        const { season, season_type, week } = state || {};
        els.metaPill.textContent = `Season: ${season ?? "‚Äî"} ¬∑ Week: ${week ?? "‚Äî"} (${season_type || "‚Äî"})`;

        // Only allow fully completed weeks in standings.
        // If week=3 is the current/next upcoming week, only weeks 1 & 2 have concluded:
        const concludedWeek = Math.max(0, (week || 0) - 1);
        if (concludedWeek < 1) {
          els.subtitle.textContent = "No concluded weeks found. No standings to display yet.";
          els.raw.textContent = "[]";
          return;
        }

        els.subtitle.textContent = `Fetching matchups for Weeks 1 ‚Üí ${concludedWeek}‚Ä¶`;

        const [users, rosters] = await Promise.all([
          fetchJson(`${BASE}/league/${LEAGUE_ID}/users`),
          fetchJson(`${BASE}/league/${LEAGUE_ID}/rosters`)
        ]);
        const userById = new Map((users || []).map(u => [u.user_id, u]));
        const rosterToUser = new Map((rosters || []).map(r => [r.roster_id, r.owner_id]));
        const nameByRoster = new Map();
        const ownerDisplayByRoster = new Map();

        // Fill maps for name, owner display, and avatar
        for (const [rid, uid] of rosterToUser.entries()) {
          const user = userById.get(uid);
          const teamName = deriveTeamName(user);
          nameByRoster.set(rid, teamName);
          ownerDisplayByRoster.set(rid, user?.display_name || user?.username || "Unknown Manager");
          if (user?.avatar) {
            const url = `https://sleepercdn.com/avatars/thumbs/${user.avatar}`;
            rosterToAvatar.set(rid, url);
          }
        }

        // Now fetch only up to concludedWeek instead of all the way to 'week'
        const weeks = Array.from({ length: concludedWeek }, (_, i) => i + 1);
        const results = [];
        const CONCURRENCY = 4;
        let i = 0;
        async function worker() {
          while (i < weeks.length) {
            const myIndex = i++;
            const wk = weeks[myIndex];
            const data = await fetchJson(`${BASE}/league/${LEAGUE_ID}/matchups/${wk}`);
            results.push({ week: wk, data });
            await sleep(40);
          }
        }
        await Promise.all(Array.from({ length: CONCURRENCY }, worker));
        results.sort((a,b) => a.week - b.week);

        const combined = [];
        for (const { week: wk, data } of results) {
          const groups = new Map();
          for (const itm of (data || [])) {
            const mid = itm.matchup_id ?? -1;
            if (!groups.has(mid)) groups.set(mid, []);
            groups.get(mid).push(itm);
          }
          for (const [mid, arr] of groups.entries()) {
            const teams = arr.map(t => {
              const rid = t.roster_id;
              const pts = effectivePoints(t);
              const userId = rosterToUser.get(rid);
              const user = userById.get(userId);
              const avatar_url = user?.avatar
                ? `https://sleepercdn.com/avatars/thumbs/${user.avatar}`
                : "";
              return {
                roster_id: rid,
                team_name: nameByRoster.get(rid) || `Roster ${rid}`,
                owner_display: ownerDisplayByRoster.get(rid) || "",
                points: typeof pts === "number" ? Math.round(pts * 100) / 100 : pts,
                players_points: t.players_points || {},
                starters: (t.starters || []).map(pid => `${pid} // ${allPlayersData[pid]?.full_name ?? 'defense'}`),
                players: (t.players || []).map(pid => `${pid} // ${allPlayersData[pid]?.full_name ?? 'defense'}`),
                avatar_url
              };
            });
            const top = Math.max(...teams.map(x => x.points ?? 0));
            const winners = teams.filter(x => (x.points ?? 0) === top).map(x => x.roster_id);
            combined.push({
              season,
              week: wk,
              matchup_id: mid,
              teams,
              winner_roster_ids: winners
            });
          }
        }

        const groupedByWeek = combined.reduce((acc, m) => {
          (acc[m.week] ||= []).push(m);
          return acc;
        }, {});
        for (const wk in groupedByWeek) {
          groupedByWeek[wk].sort((a,b) => (a.matchup_id ?? 0) - (b.matchup_id ?? 0));
        }

        renderWeeks(groupedByWeek, summariesData.summaries);
        els.countPill.textContent = `Matchups: ${combined.length}`;
        els.raw.textContent = JSON.stringify(combined, null, 2);
        els.subtitle.textContent = `Loaded ${combined.length} matchup rows from Week 1 ‚Üí ${concludedWeek}.`;

        els.downloadJsonBtn.onclick = () => download(
          `sleeper_matchups_${season}_through_w${concludedWeek}.json`,
          "application/json",
          JSON.stringify(combined, null, 2)
        );

        const csvRows = flattenForCsv(combined);
        els.downloadCsvBtn.onclick = () => download(
          `sleeper_matchups_${season}_through_w${concludedWeek}.csv`,
          "text/csv",
          csvRows.length ? toCSV(csvRows) : ""
        );

        // === COMPUTE AND RENDER LEAGUE RECORDS/STATS (only for concluded weeks) ===
        computeAndRenderLeagueRecords(combined);

      } catch (err) {
        console.error(err);
        showError(`<div class="err">Error</div>
          <div>Something went wrong while fetching data: <span class="mono">${(err && err.message) || err}</span></div>
          <div><small>Please verify your league ID and try again, or wait‚ÄîSleeper may be rate limiting or temporarily unavailable.</small></div>`);
        els.subtitle.textContent = "Unable to load data.";
        els.raw.textContent = "[]";
      }
    }

    // Compute stats function for the current season's data
    function computeAndRenderLeagueRecords(combined) {
      if (!combined || !combined.length) {
        document.getElementById('recordsList').innerHTML = "<li>No data available yet.</li>";
        return;
      }

      // 1) TEAM RECORDS
      let allScores = []; // { roster_id, team_name, points, week }
      let streakTracker = new Map();
      let standingsMap = new Map(); // { [roster_id]: { w:0, l:0, t:0, pf:0, pa:0, team_name:string } }

      for (const m of combined) {
        const highest = Math.max(...m.teams.map(t => t.points ?? 0));
        const winners = m.teams.filter(t => (t.points ?? 0) === highest);
        const tie = winners.length > 1;

        let allRosterIds = m.teams.map(t => t.roster_id);
        let rosterPointsMap = new Map(m.teams.map(t => [t.roster_id, t.points ?? 0]));

        for (const t of m.teams) {
          allScores.push({
            roster_id: t.roster_id,
            team_name: t.team_name,
            points: t.points,
            week: m.week
          });

          if (!standingsMap.has(t.roster_id)) {
            standingsMap.set(t.roster_id, {
              w: 0, l: 0, t: 0, pf: 0, pa: 0, team_name: t.team_name
            });
          }
          let dataSt = standingsMap.get(t.roster_id);
          dataSt.pf += (t.points ?? 0);

          let oppSum = 0;
          for (const rid of allRosterIds) {
            if (rid !== t.roster_id) {
              oppSum += (rosterPointsMap.get(rid) ?? 0);
            }
          }
          dataSt.pa += oppSum;
          standingsMap.set(t.roster_id, dataSt);

          if (!streakTracker.has(t.roster_id)) {
            streakTracker.set(t.roster_id, {
              currentStreak: 0,
              bestStreak: 0,
              loseStreak: 0,
              worstStreak: 0,
              lastResult: null 
            });
          }
          let dataStreak = streakTracker.get(t.roster_id);

          let result = 'L';
          if (tie && winners.map(x=>x.roster_id).includes(t.roster_id)) {
            result = 'T';
          } else if (!tie && winners.map(x=>x.roster_id).includes(t.roster_id)) {
            result = 'W';
          }

          if (result === 'W') {
            dataSt.w++;
          } else if (result === 'T') {
            dataSt.t++;
          } else {
            dataSt.l++;
          }
          standingsMap.set(t.roster_id, dataSt);

          if (result === 'W') {
            if (dataStreak.lastResult === 'W') {
              dataStreak.currentStreak += 1;
            } else {
              dataStreak.currentStreak = 1;
            }
            dataStreak.bestStreak = Math.max(dataStreak.bestStreak, dataStreak.currentStreak);
            dataStreak.loseStreak = 0;
          } else if (result === 'L') {
            if (dataStreak.lastResult === 'L') {
              dataStreak.loseStreak += 1;
            } else {
              dataStreak.loseStreak = 1;
            }
            dataStreak.worstStreak = Math.max(dataStreak.worstStreak, dataStreak.loseStreak);
            dataStreak.currentStreak = 0;
          } else {
            dataStreak.currentStreak = 0;
            dataStreak.loseStreak = 0;
          }
          dataStreak.lastResult = result;
          streakTracker.set(t.roster_id, dataStreak);
        }
      }

      let highestSingle = allScores.reduce((a,b) => b.points > a.points ? b : a, { points: -Infinity });
      let lowestSingle = allScores.reduce((a,b) => b.points < a.points ? b : a, { points: Infinity });

      let bestStreak = { roster_id: 0, team_name: 'N/A', value: 0 };
      let worstStreak = { roster_id: 0, team_name: 'N/A', value: 0 };

      for (const [rid, stats] of streakTracker.entries()) {
        if (stats.bestStreak > bestStreak.value) {
          bestStreak = {
            roster_id: rid,
            team_name: standingsMap.get(rid)?.team_name || `Roster ${rid}`,
            value: stats.bestStreak
          };
        }
        if (stats.worstStreak > worstStreak.value) {
          worstStreak = {
            roster_id: rid,
            team_name: standingsMap.get(rid)?.team_name || `Roster ${rid}`,
            value: stats.worstStreak
          };
        }
      }

      // 2) PLAYER RECORDS (highest single-game for overall and by position)
      const bestPlayers = {
        overall: { pid: null, name: "", position: "", points: 0, week: null },
        QB:     { pid: null, name: "", position: "QB", points: 0, week: null },
        RB:     { pid: null, name: "", position: "RB", points: 0, week: null },
        WR:     { pid: null, name: "", position: "WR", points: 0, week: null },
        TE:     { pid: null, name: "", position: "TE", points: 0, week: null },
        K:      { pid: null, name: "", position: "K", points: 0, week: null }
      };

      for (const match of combined) {
        const { week } = match;
        for (const team of match.teams) {
          for (const s of (team.starters || [])) {
            const [pid, fullName] = s.split(" // ");
            const pts = (team.players_points || {})[pid] ?? 0;
            const player = allPlayersData[pid];
            if (!player) continue;
            const pos = player.position || "UNK";
            if (pts > bestPlayers.overall.points) {
              bestPlayers.overall = {
                pid, name: fullName, position: pos, points: pts, week
              };
            }
            if (bestPlayers[pos] && pts > bestPlayers[pos].points) {
              bestPlayers[pos] = {
                pid, name: fullName, position: pos, points: pts, week
              };
            }
          }
        }
      }

      const recordsList = document.getElementById('recordsList');
      function recordHeader(txt) {
        return `<li style="font-size:17px; margin:12px 0 6px; font-weight:700;">${txt}</li>`;
      }

      recordsList.innerHTML = `
        <!-- TEAM RECORDS -->
        ${recordHeader("TEAM RECORDS")}
        <li style="font-size:15px; margin-bottom:8px;">
          <strong>ü•á Highest Single-Game Score (Team):</strong>
          ${avatarAndName(highestSingle.roster_id, highestSingle.team_name)}
          with ${fmt(highestSingle.points)} pts (Week ${highestSingle.week || '‚Äì'})
        </li>
        <li style="font-size:15px; margin-bottom:8px;">
          <strong>üí© Lowest Single-Game Score (Team):</strong>
          ${avatarAndName(lowestSingle.roster_id, lowestSingle.team_name)}
          with ${fmt(lowestSingle.points)} pts (Week ${lowestSingle.week || '‚Äì'})
        </li>
        <li style="font-size:15px; margin-bottom:8px;">
          <strong>ü•á Best Winning Streak (Team):</strong>
          ${avatarAndName(bestStreak.roster_id, bestStreak.team_name)}
          with ${bestStreak.value} consecutive win(s)
        </li>
        <li style="font-size:15px; margin-bottom:8px;">
          <strong>üí© Worst Losing Streak (Team):</strong>
          ${avatarAndName(worstStreak.roster_id, worstStreak.team_name)}
          with ${worstStreak.value} consecutive loss(es)
        </li>

        <!-- PLAYER RECORDS -->
        ${recordHeader("PLAYER RECORDS")}
        <li style="font-size:15px; margin-bottom:8px;">
          <strong>ü•á Top Single-Game (All Positions):</strong>
          ${bestPlayers.overall.name} (${bestPlayers.overall.position})
          with ${fmt(bestPlayers.overall.points)} pts (Week ${bestPlayers.overall.week || '‚Äì'})
        </li>
        <li style="font-size:15px; margin-bottom:8px;">
          <strong>QB üèÜ Highest Single-Game:</strong>
          ${bestPlayers.QB.name || '‚Äî'} 
          with ${fmt(bestPlayers.QB.points)} pts (Week ${bestPlayers.QB.week || '‚Äì'})
        </li>
        <li style="font-size:15px; margin-bottom:8px;">
          <strong>RB üèÜ Highest Single-Game:</strong>
          ${bestPlayers.RB.name || '‚Äî'}
          with ${fmt(bestPlayers.RB.points)} pts (Week ${bestPlayers.RB.week || '‚Äì'})
        </li>
        <li style="font-size:15px; margin-bottom:8px;">
          <strong>WR üèÜ Highest Single-Game:</strong>
          ${bestPlayers.WR.name || '‚Äî'} 
          with ${fmt(bestPlayers.WR.points)} pts (Week ${bestPlayers.WR.week || '‚Äì'})
        </li>
        <li style="font-size:15px; margin-bottom:8px;">
          <strong>TE üèÜ Highest Single-Game:</strong>
          ${bestPlayers.TE.name || '‚Äî'} 
          with ${fmt(bestPlayers.TE.points)} pts (Week ${bestPlayers.TE.week || '‚Äì'})
        </li>
        <li style="font-size:15px; margin-bottom:8px;">
          <strong>K üèÜ Highest Single-Game:</strong>
          ${bestPlayers.K.name || '‚Äî'}
          with ${fmt(bestPlayers.K.points)} pts (Week ${bestPlayers.K.week || '‚Äì'})
        </li>
      `;

      // Build a collapsible for the standings table
      const standingsDetails = document.createElement("details");
      standingsDetails.open = false;
      const standingsSummary = document.createElement("summary");
      standingsSummary.textContent = "Standings";
      standingsDetails.appendChild(standingsSummary);

      let allTeams = [...standingsMap.values()];
      // Sort by number of wins, then PF as a tiebreak
      allTeams.sort((a,b) => {
        const winDiff = b.w - a.w;
        if (winDiff !== 0) return winDiff;
        return b.pf - a.pf;
      });

      const totalTeams = allTeams.length;
      const cutoff = totalTeams > 6 ? 6 : Math.round(totalTeams / 2);

      const standingsDiv = document.createElement("div");
      standingsDiv.style.marginTop = "10px";

      const tableHtml = `
        <table style="width:100%; border-collapse:collapse; margin-top:8px;" id="standingsTable">
          <thead>
            <tr>
              <th data-col="team">Team</th>
              <th data-col="record">W-L-T</th>
              <th data-col="pf">PF</th>
              <th data-col="pa">PA</th>
              <th data-col="playoff">Playoff Consideration</th>
            </tr>
          </thead>
          <tbody>
            ${allTeams.map((tm, idx) => {
              const record = `${tm.w}-${tm.l}-${tm.t}`;
              const playoffStatus = (idx < cutoff)
                ? "In Playoff Hunt"
                : "Outside Looking In";
              return `
                <tr>
                  <td class="team-col">${avatarAndName(null, tm.team_name)}</td>
                  <td class="record-col">${record}</td>
                  <td class="pf-col">${fmt(tm.pf)}</td>
                  <td class="pa-col">${fmt(tm.pa)}</td>
                  <td class="playoffs-col">${playoffStatus}</td>
                </tr>`;
            }).join("")}
          </tbody>
        </table>
      `;
      standingsDiv.innerHTML = tableHtml;
      standingsDetails.appendChild(standingsDiv);
      document.getElementById("recordsList").appendChild(standingsDetails);

      // Attach sorting to each column header
      const standingsTable = standingsDiv.querySelector("#standingsTable");
      const ths = standingsTable.querySelectorAll("thead th[data-col]");
      ths.forEach((th) => {
        th.addEventListener("click", () => {
          const colType = th.getAttribute("data-col"); 
          sortStandings(standingsTable, colType, th);
        });
      });
    }

    // Track sorted states
    const standingsSortState = {};

    function sortStandings(table, colType, thElement) {
      if (!standingsSortState[colType]) {
        standingsSortState[colType] = 'asc';
      } else {
        standingsSortState[colType] = standingsSortState[colType] === 'asc' ? 'desc' : 'asc';
      }
      const direction = standingsSortState[colType];
      const rows = Array.from(table.querySelectorAll("tbody tr"));

      rows.sort((a,b) => {
        const getText = (row, sel) => (row.querySelector(sel)?.textContent || "").trim();

        if (colType === 'team') {
          const ta = getText(a, ".team-col").toLowerCase();
          const tb = getText(b, ".team-col").toLowerCase();
          return ta.localeCompare(tb) * (direction === 'asc' ? 1 : -1);
        }
        else if (colType === 'record') {
          // parse W-L-T
          const recA = getText(a, ".record-col").split("-").map(Number);
          const recB = getText(b, ".record-col").split("-").map(Number);
          const [wA, lA, tA] = recA;
          const [wB, lB, tB] = recB;
          const measureA = wA * 1000 + tA * 10 - lA;
          const measureB = wB * 1000 + tB * 10 - lB;
          return (measureA - measureB) * (direction === 'asc' ? 1 : -1);
        }
        else if (colType === 'pf') {
          const pfA = parseFloat(getText(a, ".pf-col") || "0");
          const pfB = parseFloat(getText(b, ".pf-col") || "0");
          return (pfA - pfB) * (direction === 'asc' ? 1 : -1);
        }
        else if (colType === 'pa') {
          const paA = parseFloat(getText(a, ".pa-col") || "0");
          const paB = parseFloat(getText(b, ".pa-col") || "0");
          return (paA - paB) * (direction === 'asc' ? 1 : -1);
        }
        else if (colType === 'playoff') {
          const playA = getText(a, ".playoffs-col").toLowerCase();
          const playB = getText(b, ".playoffs-col").toLowerCase();
          return playA.localeCompare(playB) * (direction === 'asc' ? 1 : -1);
        }
        return 0;
      });

      const tbody = table.querySelector("tbody");
      rows.forEach(r => tbody.appendChild(r));
    }

    els.themeToggleBtn.addEventListener("click", () => {
      document.documentElement.classList.toggle('light');
    });
    els.refreshBtn.addEventListener("click", load);
    load();

    // =========================
    // Randomized Audio Start
    // =========================
    const audio = document.querySelector('.audio-player audio');
    // Times in seconds for each desired song start:
    const timestamps = [0, 34, 201, 279, 335, 401, 536, 618, 716];

    audio.addEventListener('play', function() {
      // When play is clicked (or unpaused), jump to a random timestamp
      const randIndex = Math.floor(Math.random() * timestamps.length);
      audio.currentTime = timestamps[randIndex];
    });
  })();
  </script>
</body>
</html>
